/**
 * LCDWolf3D
 * jaburns
 */

#include "LCDWolf3D.h"
#include "nesinterface.h"

#include <avr/pgmspace.h>
#include <ks0108.h>



/**
 * NOTE: IN ORDER FOR THIS PROGRAM TO COMPILE, THE FOLLOWING FUNCTION MUST BE ADDED TO THE ks0108 LIBRARY FILE "ks0108.cpp"


// This function allows drawing a bitmap buffer to the LCD from memory rather than from flash.
void ks0108::DrawBitmapMem(const uint8_t * bitmap, uint8_t x, uint8_t y)
{
    uint8_t width, height, i, j;

    width  = *(bitmap++);
    height = *(bitmap++);

    for(j = 0; j < height / 8; j++)
    {
        this->GotoXY( x, y + (j*8) );

        for(i = 0; i < width; i++)
        {
            uint8_t displayData, yOffset, chip;

            chip = this->Coord.x/CHIP_WIDTH;

            if( this->Coord.x % CHIP_WIDTH == 0 && chip > 0 ){      // todo , ignore address 0???
                this->GotoXY( this->Coord.x, this->Coord.y );
            }

            fastWriteHigh(D_I);                 // D/I = 1
            fastWriteLow(R_W);                  // R/W = 0
            lcdDataDir(0xFF);                   // data port is output

            yOffset = this->Coord.y % 8;

            EN_DELAY(); //Necessary

            uint8_t data = *(bitmap++);
            lcdDataOut( data );

            this->Enable();
            this->Coord.x++;
        }
    }
}


*/


const uint8_t tex_wood[] PROGMEM = {
    0x6,0x6,0x76,0xF6,0xF6,0xF6,0x36,0x6,0xF6,0xF6,0x6,0xF6,0xF6,0x6,0x6,0x6,0x86,0xF6,0xF6,0x6,0xF6,0x6,0xF6,0x6,0x6,0x6,0xF6,0xF6,0x6,0xF6,0xF6,0x6,0xF6,0x6,
    0xF6,0xF6,0x6,0xF6,0xF6,0xE6,0xC6,0xE6,0xF6,0x6,0xF6,0xF6,0x6,0xF6,0x6,0xF6,0x6,0x6,0xF6,0x6,0xF6,0x6,0xF6,0xF6,0x6,0xF6,0xF6,0x6,0xF6,0xF6,
    0x7F,0xF0,0xC0,0x81,0x3,0xC1,0xF0,0x0,0xFF,0xFF,0x0,0xFF,0xFF,0xFF,0xFC,0xFE,0xFF,0xFF,0x7,0x0,0xFF,0x0,0xFF,0x0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0x87,0xF0,0xFF,
    0x0,0xFF,0xFF,0x0,0xFF,0x7F,0xFF,0xFF,0xFF,0xFF,0x0,0xFF,0xFF,0x0,0xFF,0x0,0xFF,0x0,0x0,0xFF,0x0,0xFF,0x0,0xF,0xFF,0x0,0xFF,0xFF,0x0,0xFF,0x0,
    0x0,0x7,0x1F,0x7F,0x3F,0xF,0x0,0x0,0xFF,0xFF,0x0,0xFF,0x7,0x7F,0xFF,0xFF,0xFF,0x3,0x0,0xC0,0xFF,0x0,0xFF,0x0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0xFF,0x3F,0xF,0x0,0xFF,
    0xFF,0x0,0xFF,0xE0,0xC1,0x83,0xC1,0xE0,0x0,0xFF,0xFF,0x0,0xFF,0x0,0xFF,0x0,0x0,0xFF,0x0,0xFF,0xFF,0x0,0x3F,0x0,0xFF,0xFF,0x0,0xFF,0xFC,
    0x1E,0xE0,0x0,0x0,0x80,0xF0,0xE,0x0,0xFF,0xFF,0x0,0xFF,0x0,0x0,0x1,0x1,0x0,0x0,0xF0,0xFF,0x1,0x0,0xFF,0x0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0x0,0x80,0xF0,0x0,0xFF,
    0xFF,0x0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0,0xFF,0xFF,0x0,0xFF,0x0,0xFF,0x0,0x0,0xFF,0x0,0x3,0xFF,0xFE,0xE0,0x0,0xFF,0xFF,0x0,0xFF,0x1,
    0x0,0x0,0x7,0xC,0x7,0x0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0xFF,0xFC,0xF0,0xE0,0xF0,0xFE,0xFF,0x7,0x0,0xFC,0xFF,0x0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0xFE,0xFF,0xFF,0x0,0xFF,
    0xFF,0x0,0xFF,0x80,0x3,0xF,0x7,0x1,0x0,0xFF,0xFF,0x0,0xFF,0x0,0xFF,0x0,0x0,0xFF,0xE0,0x0,0x7,0xFF,0xFF,0x0,0xFF,0xFF,0x0,0xFF,0xF0,
    0x3E,0xF8,0xE0,0xC0,0xE0,0xF8,0x1F,0x0,0xFF,0xFF,0x0,0xFF,0x3,0x1F,0x3F,0x7F,0x7F,0x1F,0x1,0x0,0xF0,0xFF,0x7,0x0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0x1F,0x7,0x0,0x0,0xFF,
    0xFF,0x0,0xFF,0xFF,0xFE,0xF8,0xFC,0xFE,0x0,0xFF,0xFF,0x0,0xFF,0x0,0xFF,0x0,0x0,0xF,0xFF,0xE0,0x0,0x3,0x3F,0x0,0xFF,0xFF,0x0,0xFF,0x0,
    0x0,0x3,0x1F,0xFF,0xFF,0x1F,0x0,0x0,0xFF,0xFF,0x0,0xFF,0xFC,0xE0,0x0,0x0,0x0,0x0,0xE0,0xFE,0x7F,0x7,0x0,0xE0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0xF0,0xFC,0xFF,0x0,0xFF,
    0xFF,0x0,0xFF,0x1F,0xFF,0xFF,0x7F,0xF,0x0,0xFF,0xFF,0x0,0xFF,0x0,0xFF,0x0,0x0,0x0,0x1F,0xFF,0xFE,0xF0,0x0,0x0,0xFF,0xFF,0x0,0xFF,0xE0,
    0xF8,0xC0,0x80,0x80,0x80,0x80,0xF8,0x0,0xFF,0xFF,0x0,0xFF,0x81,0x7,0x1F,0x3E,0x7C,0x3E,0x1F,0x7,0x80,0xC0,0xF8,0xFF,0xC0,0x0,0xFF,0xFF,0x0,0xFF,0xFF,0x7F,0x3F,
    0x0,0xFF,0x7F,0x0,0xFF,0x80,0x0,0x1,0x0,0x80,0x0,0xFF,0xFF,0x0,0xFF,0xC0,0x1F,0xFE,0xC0,0x0,0x0,0x0,0x7,0x1F,0x1E,0x0,0xFF,0xFF,0x0,0xFF,0xFF,
};


const uint8_t tex_bricks[] PROGMEM = {
    0x0,0xCC,0xFC,0xF0,0xF0,0xF0,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xFC,0x0,0x0,0x0,0xCC,0xFC,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xFC,0xFC,
    0xFC,0xFC,0xFC,0xFC,0xFC,0x0,0x0,0x0,0xC4,0xFC,0xFC,0xFC,0xF4,0xF4,0xFC,0xFC,0xFC,0xFC,0xF8,0xF8,0xF0,0xF0,0xF8,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0x0,0x0,
    0xF0,0xF3,0xF3,0xD3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xD3,0xD3,0xF0,0xF0,0xF0,0x3,0x3,0x3,0x33,0xB3,0xC3,0xE3,0xE3,0xE3,0xE3,0xE3,0xF3,0xF3,0xF3,0xF3,0xF3,
    0xF3,0xF3,0xF3,0xF3,0xF3,0xF0,0xF0,0xF0,0xF3,0xF3,0xD3,0xD3,0xD3,0xF3,0xF3,0xF3,0xD3,0xF3,0xD3,0xF3,0xF3,0x3,0x3,0x3,0xF3,0xF3,0xE3,0xE3,0xE3,0xC3,0xD0,0xD0,
    0xF,0xCB,0xCF,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0x8F,0xCF,0xCF,0x4F,0xCF,0xCF,0xCF,0xC0,0xC0,0xC0,0x48,0xCD,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xF,0xF,0xF,0xCF,
    0xCF,0x8F,0xF,0x8F,0x8F,0x8F,0x8F,0xF,0x8F,0x8F,0x8F,0x4F,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xCF,0xC0,0xC0,0xC0,0xC9,0xCE,0xCF,0xCF,0xCF,0xCF,0xF,0xF,
    0x0,0x3F,0x3A,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x0,0x0,0x0,0x30,
    0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x0,0x0,
    0xFF,0xFD,0xFF,0xFD,0xFF,0xFD,0xFD,0xFF,0xFF,0xFF,0xFF,0x0,0x0,0x0,0xC0,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0,0x0,0x0,0xE1,0xFF,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0x0,0x4,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,
    0x0,0x0,0x0,0xC,0xFC,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xF8,0x0,0x0,
    0xE0,0xE3,0xE3,0xE3,0xE3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0x3,0x3,0x3,0x13,0xF3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xF3,
    0xF0,0xF0,0xF0,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0x3,0x3,0x3,0x13,0xE3,0xE3,0xE3,0xE3,0xE3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF3,0xF0,0xF0,
    0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x0,0x0,0x0,0x18,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
    0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x0,0x0,0x0,0x18,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F
};


const uint8_t tex_bird[] PROGMEM = {
    0x8,0xCC,0xFC,0xC8,0x8,0x8,0x88,0xA8,0x28,0x28,0x28,0xA8,0xAC,0xA8,0xA8,0xA8,0xAC,0xAC,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xA8,0xAC,
    0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xA8,0xA8,0xA8,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xAC,0xA8,0xA8,0xA8,0x28,0x28,0x28,0x2C,0x8C,0xC,0x4C,0xC,0xFC,
    0x1C,0x0,0xF0,0xF3,0xF3,0xFF,0xFF,0x0,0xF3,0xFF,0xFF,0xFE,0x1D,0x9,0x3,0x7,0x1,0x0,0x1,0x3,0x3,0x7,0x7,0xF,0xF,0xF,0x1F,0x1F,0x3F,0xFF,0xE3,0x3,0x3,0x3,
    0x3,0x3,0xB,0xE3,0xF3,0x33,0x1F,0x1F,0xF,0xF,0xF,0x7,0x7,0x3,0x3,0x1,0x0,0x0,0xF,0xF,0xF,0x1F,0xFF,0x7E,0x9F,0xE1,0x0,0xFC,0xFE,0xC3,0xD0,0xD0,
    0xF,0xCB,0xCF,0xFF,0xFF,0x0,0xFF,0xFF,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x1,0x1,0x7,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x7,
    0x1,0x1,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x8,0x0,0x0,0x0,0x0,0x1,0x2,0xFF,0xFF,0x0,0xFF,0xFF,0xCF,0xF,0xF,
    0x0,0x3F,0x3A,0xFF,0xFF,0x0,0xFF,0x81,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x81,0xFF,0x0,0xFF,0xFF,0x3F,0x0,0x0,
    0xFF,0xFD,0xFF,0xFF,0xFF,0x0,0xFF,0xFF,0xE3,0x83,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x20,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x8,0x10,0x20,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x83,0xE3,0xFF,0xFF,0x0,0xFF,0xFF,0xFF,0xFF,0xFF,
    0x0,0x4,0xF8,0xFF,0xFF,0x0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x33,0x3,0x82,0xC0,0x4,0x4,0x86,0xC7,0xC3,0x82,0x0,0x70,0x30,0x30,0x10,0x8,0x0,0x0,0x0,0x0,0x0,
    0x0,0x8,0x10,0x30,0x30,0x70,0x0,0x82,0xC3,0xC7,0x86,0x4,0x4,0xC0,0x82,0x3,0x33,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0,0xFF,0xFF,0xF8,0x0,0x0,
    0xE0,0xE3,0xE3,0xEF,0xFF,0xF0,0xE3,0xE7,0xEF,0xCF,0xCF,0xDF,0xDF,0x9F,0x9F,0xBF,0x3F,0x3E,0x7C,0x7F,0x79,0xF8,0xF0,0xF0,0xF0,0xF0,0xF0,0xF8,0xC4,0x80,0x0,0x0,
    0x0,0x0,0x80,0xC4,0xF8,0xF0,0xF0,0xF0,0xF0,0xF0,0xF8,0x79,0x7F,0x7C,0x3E,0x3F,0xBF,0x9F,0x9F,0xDF,0xDF,0xDF,0xEF,0xEF,0xE7,0xE3,0xF0,0xFF,0xFF,0xF3,0xF0,0xF0,
    0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x3,0x2,0x6,0x1E,0x1C,0x1C,0x1D,0x1D,0x19,0x19,0x1B,0x13,0x13,0x36,
    0x36,0x13,0x13,0x1B,0x19,0x19,0x1D,0x1D,0x1C,0x1C,0x1E,0x1E,0x1E,0x1F,0x1F,0x3,0x1,0x1,0x19,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F
};


const uint8_t tex_bricks2[] PROGMEM = {
    0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0x18,0x18,0x0,0x0,0x0,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0x7E,0xFE,0xFE,0xFE,0xFE,0x4E,0x6,0x0,0x0,0x1E,0x3E,0xFE,
    0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0x1E,0xE,0x2,0x0,0x0,0x0,0xF8,0xFC,0xFC,0xFC,0xFC,0xFC,0x7C,0xF8,0xF8,0x78,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0x78,0xF8,0xF8,
    0x3,0x3,0x3,0x3,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x7F,0xFF,0xFF,0xFF,0xF7,0xD3,0xF7,0xBF,0xFF,0xBF,0xEF,0xF7,0xFF,0x10,0x0,0x0,0x0,0x0,0x0,0xE0,0xF0,0xF0,
    0xF0,0xF0,0xF8,0xF8,0xF8,0xF8,0xF8,0x8,0x0,0x0,0x0,0x0,0x1F,0xF,0x7,0x7,0x7,0x7,0x7,0x6,0x7,0x3,0x3,0x3,0x3,0x2,0x3,0x3,0x2,0x3,
    0xFF,0xFF,0xBF,0x3F,0xFF,0xFF,0xFF,0x3,0x1,0x0,0x0,0x0,0x80,0x83,0x8F,0x8F,0x87,0x87,0x85,0x87,0x86,0x3,0x7,0x3,0x1,0x2,0x80,0x80,0x80,0x80,0x80,0xDF,0xCF,
    0xC7,0xCF,0xC3,0xC3,0xC3,0xC3,0x83,0x3,0x0,0x0,0x0,0xE0,0xFE,0xFF,0xFF,0x3F,0x0,0x0,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x2F,0x3F,0xFF,0xFF,
    0x3,0xC3,0xC3,0xC3,0xE3,0xE3,0xE1,0xE0,0xE0,0xE0,0x0,0x0,0xFF,0xFF,0xDF,0xFF,0x3F,0xFF,0xFF,0xE7,0x3,0x0,0x0,0x0,0x7E,0xFF,0xFF,0xFF,0xFF,0xFF,0x5B,0xEF,
    0x1F,0x27,0xFF,0x9F,0xFF,0xFF,0xFF,0x0,0x0,0x0,0x0,0xFF,0xFF,0xFF,0xFF,0xFF,0x0,0x0,0x0,0xC0,0xC3,0xC1,0xC1,0xC1,0x81,0x81,0x81,0x81,0x81,0x81,0x3,0x3,
    0x0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xBB,0xFF,0x0,0x0,0x7F,0xFF,0xD7,0xBF,0xF7,0xFF,0xFF,0xFF,0x0,0x0,0x0,0x0,0x0,0x7,0x3F,0x7F,0x7F,0x3F,0x17,0x1F,
    0x1D,0x1F,0x1C,0x1C,0x1F,0xF,0x0,0x0,0x0,0x0,0x0,0xF,0x1F,0xF,0xF,0x7,0x0,0x0,0x0,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1,0x0,0x0,
    0x0,0x7F,0x7F,0x7F,0x7F,0x7F,0x1F,0x1F,0x1F,0x1,0x0,0x0,0x0,0xFF,0xFF,0xFF,0xF7,0xFD,0xFF,0x7F,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,
    0xFC,0xFC,0xFC,0x7C,0xFC,0xFC,0xFC,0xFE,0xFE,0xFE,0xFE,0xFE,0x7E,0xFE,0xDE,0xFE,0xFE,0xBE,0xFE,0xFE,0x7E,0x7E,0xFE,0x7E,0xFE,0xFE,0xFE,0x6,0x0,0x0,0x0,
    0x0,0xF0,0xF8,0xF8,0xF8,0xF8,0x78,0x78,0xF0,0xF0,0xF0,0x70,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xC0,0xC0,0xC0,0xC0,0xC7,0xC7,0xC3,0xC3,
    0xC3,0xC3,0x3,0x3,0x3,0x5,0x7,0x7,0x6,0xC,0x7,0x3,0x7,0x5,0x7,0x3,0x7,0x5,0x7,0x7,0x7,0x6,0x7,0x7,0x5,0x7,0x7,0x6,0x5,0x0,0x0,0x0,0x0,
    0x0,0xF,0x7,0x3,0x3,0x3,0x1,0x1,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x1,0x2,0x0,0x3,0x1,0x2,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0xF,
    0xF,0xF,0xF,0xE,0x6,0xE,0xE,0x0,0x0,0x18,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1C,0x4,0x0,0x0
};


const float ONETWENTY8_OVER_PI = 40.743665431525F;


// 20 x 21
const uint8_t sprite_pistol[] PROGMEM = {
    0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,1,1,2,1,1,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,1,1,1,2,1,1,1,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,1,2,1,1,1,1,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,0,0,0,0,1,1,2,2,2,2,2,1,1,0,0,0,0,0,0,
    0,0,0,0,0,1,1,1,2,2,2,1,1,1,1,0,0,0,0,0,
    0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,1,0,0,0,0,
    0,0,0,1,2,2,1,1,1,1,1,1,1,2,2,1,0,0,0,0,
    0,0,0,1,2,2,1,1,1,1,1,1,1,2,2,2,1,0,0,0,
    0,0,0,1,2,1,1,2,2,2,2,2,2,2,2,2,1,0,0,0,
    0,0,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,0,0,0,
    0,0,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,0,0,0,
    0,0,1,2,2,2,1,2,2,2,2,2,2,2,2,2,1,0,0,0,
    0,0,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,0,0,0,
    0,0,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,0,0,
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
    1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1
};


const uint8_t *textures[] =
{
    0,
    tex_wood,
    tex_bricks,
    tex_bird,
    tex_bricks2
};


const uint8_t level[] PROGMEM = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,2,2,3,2,2,3,2,2,3,2,2,4,4,4,4,4,4,4,4,4,4,4,1,
  1,2,0,0,0,0,0,0,0,0,0,2,4,0,0,0,0,0,0,0,0,0,4,1,
  1,3,0,0,0,0,0,0,0,0,0,3,4,0,0,0,0,0,0,0,0,0,4,1,
  1,2,0,0,0,3,2,2,2,0,0,2,4,0,0,4,0,4,0,4,0,0,4,1,
  1,2,0,0,0,2,2,0,0,0,0,2,4,0,0,0,0,0,0,0,0,0,4,1,
  1,3,0,0,0,3,3,0,0,0,0,3,4,0,0,4,0,0,0,4,0,0,4,1,
  1,2,2,0,2,2,2,0,0,0,0,2,4,0,0,0,0,4,4,4,0,0,4,1,
  1,0,2,3,2,0,2,2,0,2,2,2,4,4,4,4,4,0,0,0,4,4,4,1,
  1,0,0,0,0,0,0,4,0,4,4,4,4,4,4,4,0,0,0,0,0,4,4,1,
  1,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,1,
  1,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0,0,0,3,0,0,0,4,1,
  1,0,0,0,0,0,0,4,0,4,4,4,0,0,0,0,0,0,0,0,0,0,4,1,
  1,0,0,0,0,0,0,4,3,4,4,4,4,4,4,4,0,0,0,0,0,4,4,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,4,4,4,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,1,
  1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
  1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,
  1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,
  1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
  1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};






SCREENBUFFER screenBuffer;

float px =  70.0f;
float py = 170.0f;
float pa = -3.14159265f / 2.0f;


void castRay( float x, float y, float angle, uint8_t screenX, SLICE *result )
{
    float ox = x;        // origin coordinates
    float oy = y;

    float offsetAngle = ( (float)screenX * ( 3.14159265f / 3.0f ) ) / 128.0f - ( 3.14159265f / 6.0f );
    angle += offsetAngle;

    boolean yAxisWall = false;

    float blockX = (float)( (uint8_t)( x / BLOCK_SIZE ) );    // The coordinate of the block we're sitting in
    float blockY = (float)( (uint8_t)( y / BLOCK_SIZE ) );

    boolean stepXpositive;
    boolean stepYpositive;

    float cosine = cos( angle );
    float sine   = sin( angle );

    if( sine   <  0.000001f && sine   >= 0.0f ) sine   =  0.000001f;
    if( sine   > -0.000001f && sine   <  0.0f ) sine   = -0.000001f;
    if( cosine <  0.000001f && cosine >= 0.0f ) cosine =  0.000001f;
    if( cosine > -0.000001f && cosine <  0.0f ) cosine = -0.000001f;

    float oneOverCosine = 1.0f / cosine;
    float oneOverSine   = 1.0f / sine;

    float xNext_x, xNext_y, xNext_l;
    float yNext_x, yNext_y, yNext_l;

    do
    {
        xNext_x = blockX * BLOCK_SIZE_F;
        if( cosine > 0 ) xNext_x += BLOCK_SIZE_F;
        xNext_x -= x;
        xNext_l = xNext_x * oneOverCosine;

        yNext_y = blockY * BLOCK_SIZE_F;
        if( sine > 0 ) yNext_y += BLOCK_SIZE_F;
        yNext_y -= y;
        yNext_l = yNext_y * oneOverSine;

        if( xNext_l < yNext_l )
        {
            yAxisWall = true;
            xNext_y = xNext_l * sine;
            blockX += cosine > 0 ? 1.0f : -1.0f ;
            x += xNext_x;
            y += xNext_y;
        }
        else
        {
            yAxisWall = false;
            yNext_x = yNext_l * cosine;
            blockY += sine > 0 ? 1.0f : -1.0f ;
            x += yNext_x;
            y += yNext_y;
        }

        result->textureId = pgm_read_byte( &level[ (uint16_t)( blockX + MAP_WIDTH * blockY ) ] );
    }
    while( result->textureId == 0 );



    result->targetBlockX = blockX;
    result->targetBlockY = blockY;

    if( yAxisWall ) {
        result->textureOffset = (uint8_t)( (uint16_t)( y * 64.0f / BLOCK_SIZE_F ) % 64 );
    } else {
        result->textureOffset = (uint8_t)( (uint16_t)( x * 64.0f / BLOCK_SIZE_F ) % 64 );
    }

    float dx = x - ox;
    float dy = y - oy;
    float dd = sqrt( dx*dx + dy*dy ) * cos( offsetAngle );

    result->sliceHeight = (uint8_t)( VISPLANEDIST_TIMES_WALLHEIGHT / dd );
}



void drawSlice( uint8_t screenX, SLICE *slice )
{
    uint8_t offsetY   = ( slice->sliceHeight >  64 ) ? ( 0 ) : ( 32 - ( slice->sliceHeight >> 1 ) );
    uint8_t overflowY = ( slice->sliceHeight <= 64 ) ? ( 0 ) : ( ( slice->sliceHeight - 64 ) >> 1 );

    for( uint16_t y = 0 ; y < slice->sliceHeight && y < 64 ; ++y )
    {
        if( GET_WALL_DOT( textures[ slice->textureId ] , slice->textureOffset , ( ( y + overflowY ) << 6 ) / slice->sliceHeight ) )
        {
            SET_PIXEL( screenX, offsetY + y );
        }
    }
}

boolean shouldInterpolate( SLICE *sliceA, SLICE *sliceB )
{
    if( sliceA->textureId != sliceB->textureId ) return false;

    uint8_t xDiff = UNSIGNED_DIFF( sliceA->targetBlockX, sliceB->targetBlockX );
    uint8_t yDiff = UNSIGNED_DIFF( sliceA->targetBlockY, sliceB->targetBlockY );

    if( xDiff == 0 && yDiff <= 1 ) return true;
    if( xDiff <= 1 && yDiff == 0 ) return true;

    return false;
}

void render()
{
    memset( screenBuffer.data, 0, 1024 );    // Clear the screen buffer

    SLICE sliceA, sliceB;
    SLICE sliceX[ 3 ];

    castRay( px, py, pa, 0, &sliceA );

    for( uint8_t x = 4 ; x < 128 ; x += 4 )
    {
        castRay( px, py, pa, x, &sliceB );

        if( shouldInterpolate( &sliceA , &sliceB ) )
        {
            sliceX[1].textureId     = sliceA.textureId;
            sliceX[1].textureOffset = ( sliceA.textureOffset + sliceB.textureOffset ) >> 1 ;
            sliceX[1].sliceHeight   = ( sliceA.sliceHeight   + sliceB.sliceHeight   ) >> 1 ;
        }
        else castRay( px, py, pa, x - 4, &sliceX[1] );

        sliceX[0].textureId     =   sliceA.textureId;
        sliceX[0].textureOffset = ( sliceA.textureOffset + sliceX[1].textureOffset ) >> 1 ;
        sliceX[0].sliceHeight   = ( sliceA.sliceHeight   + sliceX[1].sliceHeight   ) >> 1 ;

        sliceX[2].textureId     =   sliceX[1].textureId;
        sliceX[2].textureOffset = ( sliceX[1].textureOffset + sliceB.textureOffset ) >> 1 ;
        sliceX[2].sliceHeight   = ( sliceX[1].sliceHeight   + sliceB.sliceHeight   ) >> 1 ;

        drawSlice( x - 3, &sliceX[0] );
        drawSlice( x - 2, &sliceX[1] );
        drawSlice( x - 1, &sliceX[2] );
        drawSlice( x,     &sliceB    );

        sliceA = sliceB;
    }

    //Draw pistol
    uint16_t i = 0;
    for( uint8_t y = 43 ; y < 64 ; ++y )
    for( uint8_t x = 54 ; x < 74 ; ++x )
    {
        switch( pgm_read_byte( &sprite_pistol[ i++ ] ) ) {
            case 1: SET_PIXEL( x, y ); break;
            case 2: CLR_PIXEL( x, y ); break;
        }
    }

    // Send the data on the screen buffer to the LCD screen
    GLCD.DrawBitmapMem( (uint8_t*)(&screenBuffer), 0, 0 );
}


void setup()
{
    GLCD.Init();

    nes_init( 12, 2, 3 ); // Data Clock => 12, Data Latch => 2, Serial Data => 3

    screenBuffer.width  = 128;
    screenBuffer.height =  64;
}

void loop()
{
    render();

    nes_update();

    float dx = 0;
    float dy = 0;

    if( nes_buttonDown( NES_UP ) ) {
        dx =  5.0f*cos( pa );
        dy =  5.0f*sin( pa );
    }
    if( nes_buttonDown( NES_DOWN ) ) {
        dx = -5.0f*cos( pa );
        dy = -5.0f*sin( pa );
    }
    if( nes_buttonDown( NES_LEFT ) ) {
        dx =  5.0f*cos( pa - 3.14159265f / 2.0f );
        dy =  5.0f*sin( pa - 3.14159265f / 2.0f );
    }
    if( nes_buttonDown( NES_RIGHT ) ) {
        dx = -5.0f*cos( pa - 3.14159265f / 2.0f );
        dy = -5.0f*sin( pa - 3.14159265f / 2.0f );
    }
    if( nes_buttonDown( NES_B ) ) {
        pa -= 3.14159265f / 25.0f;
    }
    if( nes_buttonDown( NES_A ) ) {
        pa += 3.14159265f / 25.0f;
    }

    px += dx;
    /*
    // Collision detection.  Still glitchy.
    uint16_t testA = (uint16_t)( ( px - HIT_WIDTH ) / BLOCK_SIZE_F );
    uint16_t testB = (uint16_t)( ( py - HIT_WIDTH ) / BLOCK_SIZE_F );
    uint16_t testC = (uint16_t)( ( py + HIT_WIDTH ) / BLOCK_SIZE_F );
    if( pgm_read_byte( &level[ testA + MAP_WIDTH * testB ] ) || pgm_read_byte( &level[ testA + MAP_WIDTH * testC ] ) ) {
        px = (float)( testA + 1 ) * BLOCK_SIZE_F + HIT_WIDTH;
    }

    testA = (uint16_t)( ( px + HIT_WIDTH ) / BLOCK_SIZE_F );
    if( pgm_read_byte( &level[ testA + MAP_WIDTH * testB ] ) || pgm_read_byte( &level[ testA + MAP_WIDTH * testC ] ) ) {
        px = (float)( testA ) * BLOCK_SIZE_F - HIT_WIDTH;
    }
    */
    py += dy;
    /*
    testA = (uint16_t)( ( py - HIT_WIDTH ) / BLOCK_SIZE_F );
    testB = (uint16_t)( ( px - HIT_WIDTH ) / BLOCK_SIZE_F );
    testC = (uint16_t)( ( px + HIT_WIDTH ) / BLOCK_SIZE_F );
    if( pgm_read_byte( &level[ testB + MAP_WIDTH * testA ] ) || pgm_read_byte( &level[ testC + MAP_WIDTH * testA ] ) ) {
        py = (float)( testA + 1 ) * BLOCK_SIZE_F + HIT_WIDTH;
    }

    testA = (uint16_t)( ( py + HIT_WIDTH ) / BLOCK_SIZE_F );
    if( pgm_read_byte( &level[ testB + MAP_WIDTH * testA ] ) || pgm_read_byte( &level[ testC + MAP_WIDTH * testA ] ) ) {
        py = (float)( testA ) * BLOCK_SIZE_F - HIT_WIDTH;
    }*/
}
